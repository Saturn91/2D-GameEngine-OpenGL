#version 400 core

in vec2 pass_textureCoords; //same name as the out in vertexShader!!
in vec3 pass_position;

out vec4 out_Colour;

uniform sampler2D textureSampler;	//is per default on Texture 0 -> see also renderer 


uniform vec3 enviromentLight;


//screen Informations
uniform float screenFormat;

//*****************************************general Light*********************************
vec3 getPixelLight(vec3 color, float distance, float range, float strenght){
	return vec3(color*(1/(distance-0.01)-1/(range)) * strenght);
}


//*****************************************Camera Light *********************************
uniform vec2 cameraLightPosition;
uniform vec3 cameraLightColor;
uniform float cameraLightStrenght;
uniform float cameraLightrange;

vec4 calculateCameraLight(){
	//calculate Distance
	
	float distanceX = cameraLightPosition.x - pass_position.x;
	float distanceY = (cameraLightPosition.y - pass_position.y) * screenFormat;
	vec2 distance = vec2(distanceX, distanceY);
	
	float distanceXY = length(distance);
	
	//calculate light
	vec3 cameraLightResult = getPixelLight(cameraLightColor, distanceXY, cameraLightrange, cameraLightStrenght);

	if(cameraLightResult.x < 0){
		cameraLightResult.x = 0;
		cameraLightResult.y = 0;
		cameraLightResult.z = 0;
	}
	
	if(distanceXY < 0.01){
		cameraLightResult = cameraLightColor*10;
	}
	vec4 light_4f;
	/*light_4f.x = enviromentLight.x + cameraLightResult.x;
	light_4f.y = enviromentLight.y + cameraLightResult.y;
	light_4f.z = enviromentLight.z + cameraLightResult.z;*/
	
	light_4f.x = cameraLightResult.x;
	light_4f.y = cameraLightResult.y;
	light_4f.z = cameraLightResult.z;
	
	return light_4f;
}

//************************************************/Camera**********************************************

//************************************************Point Lights Array***********************************

// array of lights
#define MAX_LIGHTS 10
uniform int numLights;
uniform struct Light {
   vec4 position;
   vec3 color; 
   float strenght;
   float range;
} allLights[MAX_LIGHTS];

in mat4 pass_view_projection;

vec4 calculatePointLights(){
	vec3 function_output;
	float distanceX;
	float distanceY;
	for(int i = 0; i < 10; i++){
	
		Light light = allLights[i];
		
		vec4 position = pass_view_projection * light.position;
		distanceX = position.x - pass_position.x;
		distanceY = position.y * screenFormat;
		float distance = length(vec2(distanceX, distanceY));
		vec3 lightResult = getPixelLight(light.color, distance, light.range, light.strenght);
		if(length(lightResult) > 0){
			function_output += lightResult;
		}
		
	}
	return vec4(function_output.x, function_output.y, function_output.z, 0);
}

void main(void){

	//calculate pixel color on screen
	out_Colour = texture(textureSampler, pass_textureCoords) * (calculateCameraLight() + enviromentLight + calculatePointLights());
}

